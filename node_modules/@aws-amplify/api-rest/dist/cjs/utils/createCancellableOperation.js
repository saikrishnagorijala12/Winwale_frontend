'use strict';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCancellableOperation = createCancellableOperation;
const errors_1 = require("../errors");
const serviceError_1 = require("./serviceError");
const logger_1 = require("./logger");
/**
 * @internal
 */
function createCancellableOperation(handler, abortController, operationType, timeout) {
    const abortSignal = abortController.signal;
    let abortReason;
    if (timeout != null) {
        if (timeout < 0) {
            throw new Error('Timeout must be a non-negative number');
        }
        setTimeout(() => {
            abortReason = 'TimeoutError';
            abortController.abort(abortReason);
        }, timeout);
    }
    const job = async () => {
        try {
            const response = await handler();
            if (response.statusCode >= 300) {
                throw await (0, serviceError_1.parseRestApiServiceError)(response);
            }
            return response;
        }
        catch (error) {
            if (error.name === 'AbortError' || abortSignal?.aborted === true) {
                // Check if timeout caused the abort
                const isTimeout = abortReason && abortReason === 'TimeoutError';
                if (isTimeout) {
                    const timeoutError = new Error(`Request timeout after ${timeout}ms`);
                    timeoutError.name = 'TimeoutError';
                    logger_1.logger.debug(timeoutError);
                    throw timeoutError;
                }
                else {
                    const message = abortReason ?? abortSignal.reason;
                    const canceledError = new errors_1.CanceledError({
                        ...(message && { message }),
                        underlyingError: error,
                        recoverySuggestion: 'The API request was explicitly canceled. If this is not intended, validate if you called the `cancel()` function on the API request erroneously.',
                    });
                    logger_1.logger.debug(canceledError);
                    throw canceledError;
                }
            }
            logger_1.logger.debug(error);
            throw error;
        }
    };
    if (operationType === 'internal') {
        return job();
    }
    else {
        const cancel = (abortMessage) => {
            if (abortSignal.aborted === true) {
                return;
            }
            abortController.abort(abortMessage);
            // If abort reason is not supported, set a scoped reasons instead. The reason property inside an
            // AbortSignal is a readonly property and trying to set it would throw an error.
            if (abortMessage && abortSignal.reason !== abortMessage) {
                abortReason = abortMessage;
            }
        };
        return { response: job(), cancel };
    }
}
//# sourceMappingURL=createCancellableOperation.js.map
