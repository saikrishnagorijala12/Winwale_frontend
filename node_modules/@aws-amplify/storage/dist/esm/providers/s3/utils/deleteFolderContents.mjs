import { StorageAction } from '@aws-amplify/core/internals/utils';
import { CanceledError } from '../../../errors/CanceledError.mjs';
import './client/s3data/base.mjs';
import './client/s3data/getObject.mjs';
import { listObjectsV2 } from './client/s3data/listObjectsV2.mjs';
import './client/s3data/putObject.mjs';
import './client/s3data/createMultipartUpload.mjs';
import './client/s3data/uploadPart.mjs';
import './client/s3data/completeMultipartUpload.mjs';
import './client/s3data/listParts.mjs';
import './client/s3data/abortMultipartUpload.mjs';
import './client/s3data/copyObject.mjs';
import './client/s3data/headObject.mjs';
import './client/s3data/deleteObject.mjs';
import { deleteObjects } from './client/s3data/deleteObjects.mjs';
import { getStorageUserAgentValue } from './userAgent.mjs';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const MAX_KEYS_PER_BATCH = 1000;
/**
 * Deletes all contents of a folder in S3 using batch operations
 *
 * @param params - Configuration object for the delete operation
 * @returns Promise that resolves to the removal result
 */
const deleteFolderContents = async (params) => {
    const { s3Config, bucket, folderKey, expectedBucketOwner, onProgress, abortSignal, } = params;
    try {
        const prefix = folderKey.endsWith('/') ? folderKey : `${folderKey}/`;
        const progressCallback = onProgress ??
            (() => {
                // no-op
            });
        let continuationToken;
        do {
            if (abortSignal?.aborted) {
                throw new CanceledError({ message: 'Operation was canceled' });
            }
            const listResult = await listObjectsV2({
                ...s3Config,
                userAgentValue: getStorageUserAgentValue(StorageAction.Remove),
                abortSignal,
            }, {
                Bucket: bucket,
                Prefix: prefix,
                MaxKeys: MAX_KEYS_PER_BATCH,
                ContinuationToken: continuationToken,
                ExpectedBucketOwner: expectedBucketOwner,
            });
            if (!listResult.Contents || listResult.Contents.length === 0) {
                break;
            }
            if (abortSignal?.aborted) {
                throw new CanceledError({ message: 'Operation was canceled' });
            }
            const batch = listResult.Contents.map(obj => ({ Key: obj.Key }));
            const deleteResult = await deleteObjects({
                ...s3Config,
                userAgentValue: getStorageUserAgentValue(StorageAction.Remove),
                abortSignal,
            }, {
                Bucket: bucket,
                Delete: {
                    Objects: batch,
                    Quiet: false,
                },
                ExpectedBucketOwner: expectedBucketOwner,
            });
            const deleted = deleteResult.Deleted?.map(obj => ({ path: obj.Key })) || [];
            const failed = deleteResult.Errors?.map(err => ({
                path: err.Key,
                code: err.Code,
                message: err.Message,
            })) || [];
            progressCallback({ deleted, failed });
            continuationToken = listResult.NextContinuationToken;
        } while (continuationToken);
        return { path: folderKey };
    }
    catch (error) {
        if (abortSignal?.aborted) {
            throw new CanceledError({ message: 'Operation was canceled' });
        }
        throw error;
    }
};

export { deleteFolderContents };
//# sourceMappingURL=deleteFolderContents.mjs.map
